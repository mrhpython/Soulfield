// jobs.js — specs + timeline + roadmap + backup + knowledge + agents handoff
const fs = require("fs");
const path = require("path");
const os = require("os");
const cp = require("child_process");
const { add, recall } = require("./memory.js");

const ROOT = __dirname;
const PLAN = path.join(ROOT, "data", "plan.json");
const AGENTS = path.join(ROOT, "data", "agents.json");
const SPECS_DIR = path.join(ROOT, ".agent-os", "specs");

function nowISO(){ return new Date().toISOString(); }

function loadPlan(){
  try { return JSON.parse(fs.readFileSync(PLAN, "utf-8")); }
  catch { return { version:"1.0", notes:[], projects_active:[], future_projects:[], golden:[], session:[] }; }
}
function savePlan(p){
  fs.mkdirSync(path.dirname(PLAN), { recursive:true });
  fs.writeFileSync(PLAN, JSON.stringify(p,null,2));
}
function loadAgents(){
  try {
    const j = JSON.parse(fs.readFileSync(AGENTS, "utf-8"));
    return Array.isArray(j) ? j : (j.agents || []);
  } catch { return []; }
}
function ensureSpecsDir(){
  fs.mkdirSync(SPECS_DIR, { recursive:true });
  return SPECS_DIR;
}
function sessionNote(content, tags=[]){
  const p = loadPlan();
  p.session = p.session || [];
  p.session.push({ id:Date.now().toString(), content, tags, timestamp:nowISO() });
  savePlan(p);
}
function slug(s){ return s.toLowerCase().replace(/[^a-z0-9]+/g,"-").replace(/^-|-$/g,""); }

/* ------------------------------------------------------------------ */
async function handleJob(line){
  const [cmd, ...rest] = line.trim().split(/\s+/);
  const tail = rest.join(" ");

  /* 📝 note */
  if (cmd === "!note"){
    const tags = (tail.match(/#[\w-]+/g)||[]).map(t=>t.slice(1));
    const text = tail.replace(/#[\w-]+/g,"").trim();
    const e = add(text, tags, "note");
    const plan = loadPlan();
    plan.notes = plan.notes||[];
    plan.notes.push({ id:e.id, content:text, tags, source:"chat", timestamp:e.timestamp });
    savePlan(plan);
    return `📝 saved: "${text}"  ⌁ tags:${tags.join(",")}`;
  }

  /* 🔎 recall */
  if (cmd === "!recall"){
    const tag = tail.trim().replace(/^#/,"");
    const rows = recall({ tag: tag||"all", limit:30 });
    if (!rows.length) return tag ? `no memory for #${tag}` : "no memory yet";
    return rows.map(r => `- ${r.content}  ⌁ tags:${(r.tags||[]).join(",")}`).join("\n");
  }

  /* 📋 plan-notes */
  if (cmd === "!plan-notes"){
    const items = (loadPlan().notes||[]).slice(-15);
    if (!items.length) return "no plan notes yet";
    return items.map(n => `- ${n.content}  ⌁ tags:${(n.tags||[]).join(",")}`).join("\n");
  }

  /* ⚡ plan-add active|future "Name" #tags */
  if (cmd === "!plan-add"){
    const match = line.match(/"!plan-add\s+(active|future)"?\s+"([^"]+)"/) || tail.match(/^(active|future)\s+"([^"]+)"/);
    if (!match) return 'usage: !plan-add active|future "Name" #tags';
    const status = match[1];
    const name = match[2];
    const tags = (tail.match(/#[\w-]+/g)||[]).map(t=>t.slice(1));
    const p = loadPlan();
    const obj = { name, status: status==="active" ? "planned" : "future", owner:"you", tags };
    if (status==="active") p.projects_active.push(obj); else p.future_projects.push(obj);
    savePlan(p);
    return `📌 added to ${status}: ${name}  ⌁ tags:${tags.join(",")}`;
  }

  /* 🧭 plan-list */
  if (cmd === "!plan-list"){
    const p = loadPlan();
    const fmt = (arr, icon) => arr.map((x,i)=>`${icon} ${i+1}. ${x.name}  ⌁ status:${x.status}  ⌁ tags:${(x.tags||[]).join(",")}`).join("\n") || "(none)";
    return [
      "🎯 Project Roadmap",
      "— Active —",
      fmt(p.projects_active||[], "🚀"),
      "",
      "— Future —",
      fmt(p.future_projects||[], "🌱")
    ].join("\n");
  }

  /* ✨ golden "desc" #tags */
  if (cmd === "!golden"){
    const tags = (tail.match(/#[\w-]+/g)||[]).map(t=>t.slice(1));
    const desc = tail.replace(/#[\w-]+/g,"").trim();
    if(!desc) return 'usage: !golden "desc" #tags';
    const p = loadPlan();
    p.golden = p.golden||[];
    p.golden.push({ id:Date.now().toString(), desc, tags, timestamp:nowISO() });
    savePlan(p);
    return `✨ golden saved: "${desc}"  ⌁ tags:${tags.join(",")}`;
  }

  /* ✨ golden-list [#tag] [N] */
  if (cmd === "!golden-list"){
    const parts = tail.trim().split(/\s+/).filter(Boolean);
    const tag = (parts.find(x=>x.startsWith("#"))||"").slice(1);
    const n = parseInt(parts.find(x=>/^\d+$/.test(x))||"10",10);
    const p = loadPlan();
    let rows = (p.golden||[]).slice(-n);
    if (tag) rows = rows.filter(g => (g.tags||[]).includes(tag));
    if (!rows.length) return tag ? `no golden for #${tag}` : "no golden entries yet";
    return rows.map(g => `• ${g.desc}  ⌁ tags:${(g.tags||[]).join(",")}`).join("\n");
  }

  /* 🧾 session-note "text" #tags */
  if (cmd === "!session-note"){
    const tags = (tail.match(/#[\w-]+/g)||[]).map(t=>t.slice(1));
    const text = tail.replace(/#[\w-]+/g,"").replace(/^"|"$/g,"").trim();
    if (!text) return 'usage: !session-note "text" #tags';
    sessionNote(text, tags);
    return `🗒️ session note saved: "${text}"  ⌁ tags:${tags.join(",")}`;
  }

  /* 🧭 session-list [#tag] [N] */
  if (cmd === "!session-list"){
    const parts = tail.trim().split(/\s+/).filter(Boolean);
    const tag = (parts.find(x=>x.startsWith("#"))||"").slice(1);
    const n = parseInt(parts.find(x=>/^\d+$/.test(x))||"3",10);
    const p = loadPlan();
    let rows = (p.session||[]);
    if (tag) rows = rows.filter(s => (s.tags||[]).includes(tag));
    rows = rows.slice(-n);
    if (!rows.length) return tag ? `no session items for #${tag}` : "no session items yet";
    return `🧭 session timeline (${rows.length}/${(p.session||[]).length} shown${tag?` for #${tag}`:""})\n` +
      rows.map(s => `• ${s.content}  ⌁ tags:${(s.tags||[]).join(",")}  ⌁ ${s.timestamp}`).join("\n");
  }

  /* 💾 backup [label] */
  if (cmd === "!backup"){
    const label = (tail.trim()||"snapshot").replace(/\s+/g,"_");
    const out = path.join(os.homedir(), `${label}-backup.${new Date().toISOString().slice(0,10)}.zip`);
    try {
      cp.execSync(`zip -qr "${out}" . -x "node_modules/*" "receipts/*"`, { cwd: ROOT });
      return `📦 backup created → ${out}`;
    } catch(e){ return `❌ backup failed: ${e.message}`; }
  }

  /* 📚 !learn */
  if (cmd === "!learn"){
    const tags = (tail.match(/#[\w-]+/g)||[]).map(t=>t.slice(1));
    const text = tail.replace(/#[\w-]+/g,"").trim();
    if(!text) return 'usage: !learn <text> #tag #tag2';
    const e = add(text, tags.length?tags:["knowledge"], "knowledge");
    return `📚 learned: "${text}"  ⌁ tags:${e.tags.join(",")}`;
  }

  /* 📖 !knowledge-list [#tag] [N] */
  if (cmd === "!knowledge-list"){
    const pieces = tail.trim().split(/\s+/).filter(Boolean);
    const tag = (pieces.find(p=>p.startsWith("#"))||"").replace("#","");
    const n = parseInt(pieces.find(p=>/^\d+$/.test(p))||"10",10);
    const rows = recall({ tag: tag||"knowledge", limit:n });
    if(!rows.length) return tag ? `no knowledge for #${tag}` : "no knowledge yet";
    return rows.map(r=>`• ${r.content}  ⌁ tags:${(r.tags||[]).join(",")}`).join("\n");
  }

  /* 📥 !learn-file <relative/path> [#tag...] */
  if (cmd === "!learn-file"){
    const m = tail.trim().match(/^(\S+)(.*)$/);
    if(!m) return 'usage: !learn-file <relative/path> [#tag #tag2]';
    const rel = m[1];
    const extraTags = (m[2].match(/#[\w-]+/g)||[]).map(t=>t.slice(1));
    const base = path.join(ROOT, rel);
    if(!fs.existsSync(base)) return `file not found: ${rel}`;
    const text = fs.readFileSync(base,"utf8").trim();
    if(!text) return `file empty: ${rel}`;
    const e = add(`[file:${rel}] ${text.slice(0,1000)}`, extraTags.length?extraTags:["knowledge"], "knowledge");
    return `📥 learned file: ${rel}  ⌁ tags:${e.tags.join(",")}`;
  }

  /* 👥 !agents — list agents from data/agents.json */
  if (cmd === "!agents"){
    const list = loadAgents();
    if (!list.length) return "no agents registered yet";
    return list.map(a => `• ${a.name} (${a.id}) — ${a.role}  ⌁ status:${a.status}`).join("\n");
  }

  /* 🛠️ !coder-open "Task title" #code #plan-aligned [#tags...] 
      "⚙️ !coder-apply [--spec <id>] [--dry] [#apply]",
     → creates .agent-os/specs/<slug>/spec.md (handoff for CoderOS) */
  if (cmd === "!coder-open"){
    const raw = (raw || "").replace(/^!coder-apply\b\s*/, "").trim();
    const tags = (raw.match(/#[\w-]+/g)||[]).map(t=>t.slice(1));
    const title = raw.replace(/#[\w-]+/g,"").replace(/^"|"$/g,"").trim();
    if (!title) return 'usage: !coder-open "Task title" #code #plan-aligned [#tag...]';
    if (!tags.includes("code") || !(tags.includes("plan-aligned") || tags.includes("plan_aligned"))){
      return "⛔ coder-open requires #code and #plan-aligned tags";
    }
    const dir = ensureSpecsDir();
    const id = `${Date.now()}-${slug(title)}`;
    const specDir = path.join(dir, id);
    fs.mkdirSync(specDir, { recursive:true });
    const body = [
      `# ${title}`,
      "",
      "## Intent",
      "- What to build:",
      "- Why it matters (plan link / golden checkpoint):",
      "",
      "## Acceptance criteria",
      "- [ ] ...",
      "- [ ] ...",
      "",
      "## Context",
      "- Related tags: " + tags.map(t=>`#${t}`).join(" "),
      "- Owner: you",
      "- Opened: " + nowISO(),
      "",
      "## Steps (proposed)",
      "1. Planning & scaffolding",
      "2. Implement feature",
      "3. Tests / basic validation",
      "4. Commit (guarded) & PR"
    ].join("\n");
    fs.writeFileSync(path.join(specDir,"spec.md"), body);
    return `🛠️ coder handoff created → .agent-os/specs/${id}/spec.md`;
  }

  /* 🏃 !coder-run — summarize newest spec (read-only) */
  if (cmd === "!coder-run"){
    const base = ensureSpecsDir();
    const dirs = fs.readdirSync(base).filter(d => fs.existsSync(path.join(base,d,"spec.md"))).sort().reverse();
    if (!dirs.length) return "no specs yet";
    const newest = path.join(base, dirs[0], "spec.md");
    const md = fs.readFileSync(newest,"utf8");
    const title = (md.match(/^#\s*(.*)$/m)||[])[1] || dirs[0];
    const ac = (md.split("## Acceptance criteria")[1]||"").split("##")[0]||"";
    return `📄 ${title}\n— file: ${newest.replace(process.env.HOME,"~")}\n\nAcceptance criteria:\n${(ac||"").trim()||"(none)"}`;
  }
  
  /* ⚙️ coder-apply — run approved commands from a spec (dry-run by default)
   Usage: !coder-apply [--spec <id>] [--dry] [#apply]
   Reads commands under: "## Run (approved)" in spec.md
   Safety: whitelist + no shell control chars; logs to .agent-os/runs/*.log */
{
  const RUNS_DIR = path.join(ROOT, ".agent-os", "runs");
  const WHITELIST = new Set(["echo","ls","cat"]); // expand later (e.g., "node")

  function ensureRunsDir(){
    fs.mkdirSync(RUNS_DIR, { recursive:true });
    return RUNS_DIR;
  }
  function newestSpecFile(){
    if (!fs.existsSync(SPECS_DIR)) return null;
    const dirs = fs.readdirSync(SPECS_DIR)
      .filter(d => fs.existsSync(path.join(SPECS_DIR,d,"spec.md")))
      .sort().reverse();
    return dirs.length ? path.join(SPECS_DIR, dirs[0], "spec.md") : null;
  }
  function specFileById(id){
    const p = path.join(SPECS_DIR, id, "spec.md");
    return fs.existsSync(p) ? p : null;
  }
  function extractRunCommands(md){
    // Grab text between "## Run (approved)" and the next "##"
    const m = md.split(/^##\s+Run\s+\(approved\)\s*$/m);
    if (m.length < 2) return [];
    const after = m[1];
    const block = after.split(/^##\s+/m)[0] || "";
    // list items starting with "- " or "• "
    return block.split("\n")
      .map(s => s.trim().replace(/^[-•]\s+/,"").trim())
      .filter(s => s && !s.startsWith("#"));
  }
  function isSafe(cmd){
    // Disallow shell control/redirect chars to keep execution simple
    if (/[;&|><`$]/.test(cmd)) return { ok:false, reason:"contains control/redirect characters" };
    const first = cmd.split(/\s+/)[0];
    if (!WHITELIST.has(first)) return { ok:false, reason:`"${first}" not in whitelist` };
    return { ok:true };
  }
  function execLines(lines){
    const { execSync } = require("child_process");
    const logPath = path.join(ensureRunsDir(), `${Date.now()}-run.log`);
    const header = `# run @ ${new Date().toISOString()}  (cwd:${ROOT})\n`;
    fs.appendFileSync(logPath, header);
    const outputs = [];
    for (const line of lines){
      const stamp = `\n$ ${line}\n`;
      try {
        const out = execSync(line, { cwd: ROOT, stdio: ["ignore","pipe","pipe"], timeout: 15000, shell: "/bin/bash" });
        const txt = out.toString();
        fs.appendFileSync(logPath, stamp + txt);
        outputs.push({ cmd: line, ok:true, out: txt.slice(0,4000) });
      } catch (e){
        const errTxt = (e.stdout||"").toString() + (e.stderr||"").toString() || e.message;
        fs.appendFileSync(logPath, stamp + errTxt);
        outputs.push({ cmd: line, ok:false, out: errTxt.slice(0,4000) });
      }
    }
    return { logPath, outputs };
  }

  if (cmd === "!coder-apply"){
    const raw = (raw || "").replace(/^!coder-apply\b\s*/, "").trim();
    const tags = (raw.match(/#[\w-]+/g)||[]).map(t=>t.slice(1));
    const wantApply = tags.map(t=>t.replace(/_/g,"-")).includes("apply");
    const mSpec = raw.match(/--spec\s+(\S+)/);
    const forceDry = /\s--dry(\s|$)/.test(raw);

    const specPath = mSpec ? specFileById(mSpec[1]) : newestSpecFile();
    if (!specPath) return "no spec found (use --spec <id> or create one with !coder-open)";

    const md = fs.readFileSync(specPath,"utf8");
    const all = extractRunCommands(md);
    if (!all.length) return 'no "## Run (approved)" commands found in spec';

    // Safety filter
    const safe = [], rejected = [];
    for (const c of all){
      const chk = isSafe(c);
      if (chk.ok) safe.push(c); else rejected.push(`${c}  ⟶  ${chk.reason}`);
    }
    if (!safe.length){
      return `❌ no commands allowed by whitelist\nRejected:\n- ${rejected.join("\n- ")}`;
    }

    // Preview
    const rel = specPath.replace(os.homedir(), "~");
    const preview = [
      `📄 spec: ${rel}`,
      `🔎 candidates: ${all.length}  • allowed: ${safe.length}  • rejected: ${rejected.length}`,
      rejected.length ? `\n🚫 rejected:\n- ${rejected.join("\n- ")}\n` : ""
    ].join("\n");

    // Dry-run unless #apply and not --dry
    if (!wantApply || forceDry){
      return preview + `\n\n🧪 dry-run only — to execute, re-run with #apply (and without --dry).`;
    }

    // Execute
    const { logPath, outputs } = execLines(safe);
    const tail = outputs.slice(0,3).map(o => `- ${o.ok?"✅":"❌"} ${o.cmd}\n${o.out.trim().split("\n").slice(0,6).join("\n")}`).join("\n");
    const relLog = logPath.replace(os.homedir(),"~");
    return [
      preview,
      `\n⚙️ executing ${safe.length} command(s)…`,
      tail ? `\n— output (head) —\n${tail}` : "",
      `\n🗒️ full log → ${relLog}`
    ].join("\n");
  }
}

  /* 🆘 help */
  if (cmd === "!help"){
    return [
      "🎛️ Soulfield Command Menu",
      "─────────────────────────",
      "📝 !note <text> #tags",
      "🔍 !recall #tag",
      "📋 !plan-notes",
      "⚡ !plan-add active|future \"Name\" #tags",
      "🧭 !plan-list",
      "✨ !golden \"desc\" #tags",
      "🗒️ !session-note \"text\" #tags",
      "🧭 !session-list [#tag] [N]",
      "📚 !learn <text> #tags",
      "📖 !knowledge-list [#tag] [N]",
      "📥 !learn-file <path> [#tag..]",
      "👥 !agents",
      "🛠️ !coder-open \"Task\" #code #plan-aligned [#tag..]",
      "💾 !backup [label]",
      "📖 end of help"
    ].join("\n");
  }

  return "(🤔 unknown job)";
}

module.exports = { handleJob };
